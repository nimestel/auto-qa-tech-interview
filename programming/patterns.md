Виды паттернов **проектирования**:
1. Поведенческие - определяют взаимодействие между объектами
2. Порождающие - определяют создание объектов
3. Структурные - определяют способ организации классов и объектов

### Паттерны в автотестировании

##### 1. Структурные паттерны - позволяют структурировать код, чтобы упростить поддержку, избежать дубликатов и проблем с запутанностью

-   **Page Object** - одна точка входа, проще переиспользовать, разделение логики
-   **Page Element** - реюзабельность одних и тех же высокоуровневых компонентов и прозрачность логики
-   **Step Object** - выносим бизнес действия в отдельные методы, чтобы не дублировать код
-   **Chain** - в конце метода возвращаем контекст, с которым работаем дальше (цепочка вызовов)
-   **Factory/Page Factory** - создание объектов с уже инициализированными полями

##### 2. Паттерны данных

-   **Value Object** - высокоуровневый иммутабельный объект, который содержит в себе набор данных. передаем в метод вместо кучи отдельных полей
-   **Builder** - наглядное создание объектов с только необходимыми полями 
-   **Assert Object** - вынесение повторяющихся проверок в отдельное место
-   **Data Provider** - прогоняем одну и ту же тестовую логику на разных тестовых данных

##### 3. Технические паттерны
- **Decorator** - динамически меняем поведение объекта во время работы (добавляем новую логику), оборачивая в объект класса декоратора (капустка)
- **Proxy** - обертка над объектом, которая позволяет управлять доступом к нему (например добавить логирование, вернуть кэшированные данные)
- **Синглтон** - гарантирует, что у нас будет только один экземпляр класса

##### Прочие паттерны:
- **Фасад** - простой интерфейс, скрывающий сложную логику
- **Наблюдатель** - оповещение заинтересованных объектов об изменении и их атвоматическое обновление
- **Посетитель** - позволяет добавлять новые операции над объектами, не изменяя их классы
- **Адаптер** - преобразование интерфейса одного класса в интерфейс другого класса
- **Посредник** - позволяет уменьшить связанность множества классов между собой, благодаря перемещению этих связей в один класс-посредник
- **Хранитель** - позволяет, не нарушая инкапсуляцию, зафиксировать и сохранить внутреннее состояние объекта так, чтобы позднее восстановить его в это состояние
- **Приспособленец** - использует разделение для эффективной поддержки множества мелких объектов
- **Компоновщик** - позволяет сгруппировать множество объектов в древовидную структуру, а затем работать с ней так, как будто это единичный объект
- **Итератор** - позволяет последовательно обходить элементы составных объектов, не раскрывая их внутреннего представления
- **Состояние** - позволяет объекту изменять свое поведение в зависимости от внутреннего состояния
- **Абстрактная фабрика** - предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов, не специфицируя их конкретных классов
- **Прототип** - позволяет создавать объекты на основе уже ранее созданных объектов-прототипов
- **Мост** - разделяет абстракцию и реализацию так, чтобы они могли изменяться независимо друг от друга
