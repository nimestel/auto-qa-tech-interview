**Модификаторы доступа**
   
static
- метод или поле класса принадлежат не объекту инстансу класса, а непосредственно классу, доступ через ClassName.staticMethod()


- могут вызывать только другие статические методы.
- должны осуществлять доступ только к статическим переменным.
- не могут ссылаться на члены типа this или super.
- можно перегрузить, нельзя переопределить

static nested class
- вложенный класс, который может обращаться только к статическим полям обертывающего его класса, в том числе и приватным. Доступ к нестатическим полям обрамляющего класса может быть осуществлен только через ссылку на экземпляр обрамляющего объекта.

final
- применимо к полям, методам или классам, в целом означает неизменность


- Класс: не может иметь наследников
- Метод: не может быть переопределен в классах наследниках
- Значение локальных переменных и параметров метода не могут быть изменены после присвоения
- Поле: не может изменить свое значение после инициализации
    * Для переменных примитивного типа означает, что однажды присвоенное значение не может быть изменено.
    * Для ссылочных переменных означает, что после присвоения объекта, нельзя изменить ссылку на данный объект. Ссылку изменить нельзя, но состояние объекта изменять можно.

примитивы:
- byte - 8bit (целочисленный)
- short - 16bit (целочисленный)
- int - 32bit (целочисленный)
- long - 64bit (целочисленный) 
- char - 16bit (символьный, только один символ). Обозначается в одинарных кавычках. Например: 
  'a', 'D', '1', '9', '' и любые одиночные символы. Объекты char всегда заключены в одинарные кавычки.
- float - 32bit (дробный)
- double - 64bit (дробный)
- boolean - true или false, 0 или 1, правда/ложь (когда-то его не было в JVM)

ссылочные типы делятся на три основных вида:
1) class types - Это фактически любой класс в мире java. Например:
* String - тип, который хранит в себе строки. Строки отличаются от char тем, что могут хранить в себе от нуля до более двух миллиардов символов. Объекты String всегда заключены в двойные кавычки: "моя строка"; даже если это один символ: "ф", "9", "j","" и т.д.
* Long - тип-обертка над примитивом long. Позволяет производить дополнительные операции над численным типом. Например конвертируя его в String или наоборот.
* Object - это суперкласс для всех классов, базовый класс в мире java. От него наследуются все остальные классы. И даже те, которые будете создавать Вы.
* Отдельным подвидом class types являются классы-перечисления: Enum (enumerators). О них будет отдельный урок.

2) array types - массив является специальным типом. Он предназначен для содержания в себе любых 
других типов, в том числе и массивов (многомерные массивы)

3) interface - это третий специальный вид типов - пока просто запоминаем. Детально рассмотрим их 
далее по курсу, чтобы не перегружать этот, и так сложный, урок.


abstract
- для общего описания некой абстракции без конкретной функциональности, которая будет реализована в наследниках

- Класс: на основе него не могут создаваться объекты
- Метод: который не имеет реализации. Если в классе есть хотя бы один абстрактный метод, то весь класс должен быть объявлен абстрактным.

**Перегрузка и переопределение методов**

1. Переопределение (@Override)

Переопределение методов происходит, когда child хочет изменить поведение какой-то функциональности parent класса. Если нужно, чтоб выполнилось-таки то, что есть в методе parent, можно использовать в child конструкцию вида super.methodName(), что выполнит работу parent метода, а уже потом добавить логику.

Требования, которые нужно соблюдать:
- сигнатура метода должна быть такая же;
- возвращаемое значение должно быть таким же.

2. Перегрузка

Перегрузка методов — это свойство полиморфизма, в котором при помощи изменения сигнатуры метода можно создать разную логику действия метода, предназначенного для определенного действия

Перегрузка обычно используется, чтобы не придумывать каждый раз новое имя, когда методы отличаются только входными параметрами. 

Характерные атрибуты перегрузки метода:
- одно и то же имя метода;
- разные аргументы, разное количество аргументов;
- разный возвращаемый тип

Чем отличается переопределение от перегрузки?
- Переопределение (оверрайд) используется тогда, когда вы переписываете (переделываете,
  переопределяете) УЖЕ существующий метод.
- Перегрузка — это использование одного имени, но с разными входными параметрами.
- При перегрузке необходимый метод определяется на этапе компиляции на основе сигнатуры 
   вызываемого метода, тогда как при переопределении нужный метод будет выявлен во время выполнения исходя из реального типа объекта.

Могут ли нестатические методы перегрузить статические?
- Да. Это будут просто два разных метода для программы. Статический будет доступен по имени класса.

Могут ли быть переопределены статические методы?
- Метод в классе-наследнике, совпадающий по сигнатуре с методом из родительского класса,
  переопределен не будет, т.к переопределить базовый статический метод нельзя

Можно ли сузить уровень доступа/тип возвращаемого значения при переопределении метода?
- Нельзя сузить модификатор доступа к методу
- Нельзя изменить тип возвращаемого значения, но можно сузить возвращаемое значение, если они совместимы


**Множественное наследование в java**

Множественное наследование не реализовано в джаве, поэтому, чтобы преодолеть эту проблему, были добавлены интерфейсы.

interface означает, что именно так должны выглядеть все классы, которые реализуют данный интерфейс. Таким образом, любой код, использующий конкретный интерфейс, знает только то, какие методы вызываются для этого интерфейса, но не внутреннюю логику.

- все методы в интерфейсе — public и abstract;
- все переменные — public static final;
- классы не наследуют их (extends), реализовывают (implements). Причем реализовывать можно сколь угодно много интерфейсов.
- классы, которые реализуют интерфейс, должны предоставить реализацию всех методов, которые есть в интерфейсе.
- дефолтный метод — это реализованный метод в интерфейсе, у которого есть ключевое слово default

Отличие интерфейса от абстрактного класса:
- Интерфейс описывает только поведение. У него нет состояния (приватных полей). Соответственно, мы не сможем реализовать внутри интерфейса геттеры и сеттеры. Такова природа интерфейса: он нужен для работы с поведением, а не состоянием.
- А у абстрактного класса состояние есть: он описывает и то, и другое, то есть содержит детали реализации (приватные поля, геттеры и сеттеры)

Абстрактный класс:
- абстрактные классы имеют дефолтный конструктор; он вызывается каждый раз, когда создается потомок этого абстрактного класса;
- содержит как абстрактные методы, так и не абстрактные, в отличие от интерфейса. По большому счету может и не содержать абстрактных методов, но все равно быть абстрактным классом;
- класс, который наследуется от абстрактного, обязан реализовать только то методы, которые объявлены абстрактными;

Интерфейс:
- не имеет никакого конструктора и не может быть инициализирован;
- только абстрактные методы должны быть добавлены (не считая default methods);
- классы, реализующие интерфейс, должны реализовать все методы (не считая default methods);
- интерфейсы могут содержать только константы.


Множественного наследования в Java нет, а множественная реализация есть. Классы могут реализовывать сколько угодно интерфейсов. И один интерфейс может расширять множество других интерфейсов.
В идеале мы должны использовать наследование только когда отношение подкласса к суперклассу определяется как «является». Во всех остальных случаях рекомендуется использовать композицию.


**Коллекции**

Collection — это фреймворк, который создан для сохранения и манипуляции объектами.

Используется для выполнения следующих операций:
- поиск;
- сортировка;
- манипуляция;
- добавление;
- удаление.

Интерфейсы:
- Collection;
- List;
- Set;
- Map;
- Sorted Set;
- Sorted Map;
- Queue.

Классы:

1) Lists:
- ArrayList;
- LinkedList;

2) Sets:
- HashSet;
- LinkedHashSet;
- TreeSet.

3) Maps:
- HashMap
- TreeMap
- LinkedHashMap
- Queue
- Priority Queue.

ArrayList - массив с динамически расширяемым размером. Работа по управлению размером массива 
лежит на коллекции.

- быстрый перебор и быстрый поиск по индексу;
- медленное добавление в середину списка.
- коллекция упорядочена по индексу, но не сортирована;
- реализует RandomAccess интерфейс;

Linked List
- общая скорость работы заметно ниже, чем в ArrayList (нужно пройтись последовательно по всем объектам от 0 до нужного);
- отличный выбор для большого количества вставок и удалений в середину массива;
- каждый элемент имеет ссылку на предыдущий и следующий элементы
- элементы связаны друг с другом, то есть реализован двусвязный список;
- реализует интерфейсы списков Queue и Deque, поэтому и имеет их методы для работы.

Если ты собираешься вставлять (или удалять) в середину коллекции много элементов, то тебе лучше использовать LinkedList. Во всех остальных случаях – ArrayList.


**Исключения**

Исключение — это проблема, которая может возникнуть во время выполнения программы.

Throwable - Error
- Exception
- Runtime Exception
- Others

Error — используются JVM для отображения ошибок, после которых работа приложения уже не имеет смысла. Например StackOverFlowError, которая говорит, что стек заполнен и программа уже не может работать.

Exception — исключения, которые генерируются программно в коде, их можно перехватить и продолжить работу приложения.

есть checked и unchecked исключения
исключения:
- определяемые во время компиляции
- определеляемые во время выполнения программы

try-catch-finally — это конструкция, при помощи которой можно правильным образом перехватить и обработать исключение.

* try — может быть только один раз, в нем и происходит логика;
* catch — блок, который принимает какой-то тип исключения, их может быть множество. Например, в 
  блоке try будет генерироваться несколько исключений, которые никак друг с другом не связаны;
* finally — блок, который выполнится в любом случае, независимо от того, что делается в try, catch.


throw - для создания и выбрасывания пользовательских исключений, можно только тем, что 
наследуется от Throwable
```
throw new RuntimeException("wow");
```

throws — механизм, при помощи которого метод может выбрасывать одно или более исключений
```
private Object willThrow() throws RuntimeException, IOException, FileNotFoundException
```

try-with-resources - механизм, при помощи которого нужно правильно закрывать все ресурсы.

Ресурс — это объект (чаще всего стрим), после работы с которым нужно закрыть его, то есть вызвать метод close()

чтоб не думать о том, что нужно вызвать метод close(), мы просто определяем эту переменную в блоке try, как показано в примере и в рамках этого блока выполняем все необходимое

```
try(ZipInputStream zipOutputStream = new ZipInputStream(new FileInputStream(zipFile))) {...
```

**Отлавливание множественных ошибок**

можно объединять несколько исключений в один блок
```
catch (OneException | TwoException e) { ...
```
либо написать несколько блоков catch для каждого исключения
```
catch (OneException e) { ... }
catch (TwoException e) { ... }
```