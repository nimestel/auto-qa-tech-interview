## Event loop

Движок браузера выполняет JavaScript в одном потоке.
Он не может поставить обработку события на паузу, переключиться на другое событие, а после — возобновить выполнение первого.
Все события обрабатываются последовательно и каждое — до конца.

Список событий, подлежащих обработке формируют *очередь событий* (callback queue).

Для вышеописанного одного потока выделяется область памяти — *стек* (stack), где хранятся фреймы 
(аргументы, локальные переменные) вызываемых функций. 

Стек работает по принципу «last in — first out», т.е. «последнего положил — его же первого достаешь»

**Как все работает:**

1. Цикл событий Event loop постоянно проверяет, пуст ли стек вызовов. 
2. Если стек вызовов (stack) пуст, event loop возьмет первое событие из очереди событий (queue) и 
   отправит его в стек вызовов, который его запустит. 
3. Если стек не пуст, то выполняется текущий вызов функции из стека.

![Event loop](https://github.com/nimestel/auto-qa-tech-interview/blob/master/screenshots/event_loop1.png "Общее представление")

- Heap (Куча). В куче происходит создание нового объекта.
- Queue (Очередь). Очередь событий отвечает за отправку новых функций на трек обработки.
  Он следует структуре данных очереди, чтобы поддерживать правильную последовательность, в которой все операции должны отправляться на выполнение. Если проще, то это и есть список задач, которые должны отправиться на обработку и ждут своего часа.
- Web API. Не являются частью JavaScript, они скорее созданы на основе JS. Каждый раз, когда 
  вызывается асинхронная функция, она отправляется в API браузера. На основе команды, полученной из стека вызовов, API запускает собственную однопоточную операцию.

### Отложенное выполнение
Давайте посмотрим, как отложить выполнение функции до тех пор, пока стек не очистится.

Пример использования `setTimeout(() => {}), 0)` заключается в том, чтобы вызвать функцию, но выполнить ее после выполнения всех остальных функций в коде.

При вызове `setTimeout()`, браузер или Node.js запускают таймер. По истечении таймера (в нашем случае мы установили 0) в качестве тайм-аута, функция обратного вызова помещается в очередь событий.

Очередь событий также является местом, где инициированные пользователем события (клики мышью, ввод с клавиатуры и др.) помещаются в очередь до того, как код сможет на них отреагировать.

Event Loop отдает приоритет стеку вызовов. Сначала он обрабатывает все, что находит в стеке вызовов, а когда там ничего не остается, переходит к обработке очереди событий.

Таким образом, setTimeout с аргументом  0 не гарантирует, что обработка будет выполнена мгновенно. 
Сначала выполнятся предыдущие задачи в стеке и очереди событий.

### Схема работы

Код каждой HTML-страницы в браузере выполняется в Main Thread. Main Thread — это основной поток, где браузер выполняет JS, делает перерисовки, обрабатывает пользовательские действия и многое другое. По сути, это то место, где движок JS интегрирован в браузер.

![Event loop2](screenshots/event_loop2.png "Общее представление")

Мы видим, что единственное место, через которое задачи могут попасть в Call Stack и выполниться — это Event Loop.

Причем порядок выполнения:
1. Основное — выполнение основного JavaScript-кода на сайте (далее будем считать, что он уже 
выполнился)
2. Задачи от заказчиков — Render, Microtasks и Tasks

![Event loop3](screenshots/event_loop3.png "Частное представление")

После того как мы начали выполнять какой-либо script, в очередь Tasks ставится задача с 
выполнением этого скрипта. По мере выполнения этого кода, нам встречаются задачи от разных заказчиков, которые ставятся в соответствующие очереди. 

1. После того как завершается одна взятая задача по выполнению скрипта (задача от Tasks), Event 
   Loop идет к Microtasks (после задачи от Tasks Event Loop берет задачи от Microtasks). У него Event Loop берет задачи до тех пор, пока они не закончатся. Это значит, что если время их добавления равно времени их выполнения, то Event Loop будет бесконечно их разгребать.

2. Далее он идет к Render и выполняет задачи от него. Задачи от Render оптимизируются браузером и, 
если он посчитает, что в этом цикле не нужно ничего перерисовывать, то Event Loop просто пойдет дальше. 

3. Далее Event Loop снова берет задачи от Tasks и просит у него только одну, первую в очереди 
задачу, передает ее в CallStack и идет дальше по циклу.

Задачи из Tasks берет по одной, из Microtasks и Render - до тех пор, пока не закончатся.

Если у кого-то из заказчиков не оказалось задач, то Event Loop просто идет к следующему. И, 
наоборот, если у заказчика задачи занимают много времени, то остальные заказчики будут ждать 
своей очереди. А если задачи от какого-то заказчика оказались бесконечными, то Call Stack 
переполняется, и браузер выдаст "Страница не отвечает".




### Параллельное выполнение кода. Web workers

Cпецификация *Web workers* позволяет распараллелить выполнение JavaScript кода, с их помощью 
можно запускать фоновые потоки. 

Worker — это объект, созданный при помощи конструктора , который запускает JavaScript файл с кодом, который будет выполнен в потоке Worker’а:

`var myWorker = new Worker("worker.js");`

У каждого веб воркера, как и у главного потока, имеется свой stack, heap и event loop. Послать сообщения в веб воркер (например, передать данные для расчетов) можно с помощью метода postMessage().

`myWorker.postMessage(imageData);`

Это создаст событие типа message в очередь событий web worker’а, которое будет обработано в следующей итерации event loop воркера.

### Итоги

Цикл событий в JavaScript отличается от других языков тем, что его поток выполнения никогда не 
блокируется, кроме некоторых исключений, таких как alert или синхронный HTTP-запрос, которые не рекомендуется использовать. Поэтому даже когда приложение ожидает запросы из хранилища или ответ с сервера, оно может обрабатывать другие процессы, например пользовательский ввод.

Встроенный механизм Event Loop помогает JavaScript обрабатывать асинхронный код.