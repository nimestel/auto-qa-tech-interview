## RESTful архитектурный подход


REST — это аббревиатура от Representational State Transfer («передача состояния представления»). 

Это согласованный набор архитектурных принципов для создания более масштабируемой и гибкой сети. 

Принципы REST характерны не только для Web. REST — не протокол, так как он не задаёт деталей 
реализации.


Эти принципы отвечают на ряд вопросов:
- Какие у системы компоненты? 
- Как они должны взаимодействовать друг с другом? 
- Как быть уверенным, что можно заменять различные части системы в любое время? 
- Как система может масштабироваться для обслуживания большего числа пользователей? 


###Ограничения Филдинга

В диссертации Филдинга, первого использовавшего термин REST, есть группа архитектурных ограничений, 
которым должна удовлетворять система, соответствующая требованиям RESTful.

**Все ограничения списком:**
1. Клиент-серверная архитектура
2. Отсутствие состояния
3. Единообразие интерфейса
   1. определение ресурсов
   2. управление ресурсами через представления
   3. самодостаточные сообщения
   4. гипермедиа
4. Кэширование
5. Система слоёв
6. Код по требованию

#### Клиент-серверная архитектура

Первое ограничение указывает, что сеть должна состоять из клиентов и серверов. Сервер — это компьютер, который имеет требуемые ресурсы, а клиент — это компьютер, которому нужно взаимодействовать с ресурсами, хранящимися на сервере.

#### Отсутствие состояния

Понятие «без состояния» не означает, что серверы и клиенты его не имеют, у них просто нет необходимости отслеживать состояние друг друга. 
Когда клиент не взаимодействует с сервером, сервер не имеет представления о его существовании. Сервер также не ведёт учет прошлых запросов. 
Каждый запрос рассматривается как самостоятельный.

#### Единообразие интерфейса

Гарантирует, что между серверами и клиентами существует общий язык, который позволяет каждой части 
быть заменяемой или изменяемой, без нарушения целостности системы. 
Это достигается через 4 субограничения: идентификацию ресурсов, манипуляцию ресурсами через представления, «самодостаточные» сообщения и гипермедиа.


Когда система имеет идентификаторы для каждого ресурса, управляет ими через направление представлений от клиента серверу, содержит самодостаточные сообщения и составлена из гипермедиа, то говорят, что у неё унифицированный интерфейс. Возможно, это самый важный атрибут RESTful системы, так как он позволяет клиентам приспосабливаться к изменениям.

##### Определение ресурсов

- В REST что угодно может быть ресурсом — HTML-документ, изображение, информация о конкретном 
пользователе и т.д. 
- Каждый ресурс должен быть уникально обозначен постоянным идентификатором (URI). 
- «Постоянный» означает, что идентификатор не изменится за время обмена данными, и даже когда изменится 
  состояние ресурса. 
- Если ресурсу присваивается другой идентификатор, сервер должен сообщить клиенту, что запрос 
  был неудачным и дать ссылку на новый адрес.

##### Управление ресурсами через представления

- Клиент "управляет ресурсами", направляя серверу представления, обычно в виде JSON-объекта, 
содержащего контент, который он хотел бы добавить, удалить или изменить. 
- В REST у сервера полный контроль над ресурсами, и он отвечает за любые изменения. Когда клиент 
  хочет внести изменения в ресурсы, он посылает серверу представление того, каким он видит итоговый ресурс. Сервер принимает запрос как предложение, но за ним всё также остаётся полный контроль.

##### Самодостаточные сообщения

- Гарантирует унифицированность интерфейса у клиентов и серверов. 
- Самодостаточное сообщение содержит всю информацию, которая необходима для понимания его 
  получателем. В отдельной документации или другом сообщении не должно быть дополнительной информации.
- Суть в том, что и у сервера, и у клиента есть всё, что необходимо, в одном присланном сообщении 
  для обработки его соответствующим образом.

##### Гипермедиа

- Гипермедиа — это понятие для обозначения данных, которые содержат информацию о том, что клиенту нужно делать дальше. 
 - В REST серверы должны посылать клиентам только гипермедиа.

HTML — это один из видов гипермедиа.

Примеры:

`<a href= “http://www.recurse.com”> Check out the Recurse Center!</a>`
сообщает клиенту, что он должен сделать GET-запрос к www.recurse.com, если пользователь нажимает на ссылку.

`<img src="awesome-pic.jpg">`
говорит клиенту немедленно сделать GET-запрос к www.example.com/awesome-pic.jpg, чтобы тот отобразил изображение для пользователя.

##### Кэширование

- HTTP-ответы могут быть закешированы, то есть сохранены для дальнейшего восстановления и
  использования позже, тем самым снижая число запросов к серверу.
- Ответы сервера должны помечаться как кэшируемые или некэшируемые.  
- Кэширование происходит, когда клиент сохраняет ответы, полученные ранее от сервера. Когда эти данные нужны снова, кэширование может избавить от полного прохода данных по сети. 
- Возможность кэшировать существует благодаря самодостаточным сообщениям. Клиенту не нужно 
    беспокоиться о том, что случайно закэшируется только часть необходимой информации, а другие части потеряются.
  
Вот несколько ограничений:
- Кешируемые методы безусловно: GET или HEAD. 
- Кешируемые методы с оговорками: POST или PATCH, если указан признак "свежести" данных и 
  установлен заголовок Content-Location (en-US) 
- Не кешируемые методы: PUT и DELETE, результат их выполнения не кешируется. 
- Кешируемые коды ответа: 200, 203, 204, 206, 300, 301, 404, 405, 410, 414, 501.
- Есть специальные заголовки в ответе, которые предотвращают кеширование: например, 
  Cache-Control.
- Некоторые некешируемые запросы-ответы к определённым URI могут сделать 
  недействительным (инвалидируют) предыдущие закешированные ответы на тех же URI. Например, PUT инвалидируют все закешированные ответы GET или HEAD запросов к этой странице.


##### Система слоёв 

- Предполагает наличие бОльшего количества компонентов, чем клиент и сервер. В системе может быть 
больше одного слоя. 
- Каждый компонент ограничен способностью видеть только соседний слой и взаимодействовать только с ним. 
- Прокси — это дополнительный компонент, он ретранслирует HTTP-запросы на серверы или другие 
  прокси. Прокси-серверы могут быть полезны для балансировки нагрузки и проверок безопасности. 
- Прокси действует как сервер для начального клиента, который посылает запрос, а затем как клиент,
  когда ретранслирует эту просьбу. 
- Шлюз — это еще один дополнительный компонент, он переводит HTTP-запрос в другой протокол, 
  распространяет этот запрос, а затем переводит полученный ответ обратно в HTTP. Клиент может обращаться со шлюзом, как с обычным сервером. Пример шлюза — система, которая загружает файлы с FTP-сервера.

##### Код по требованию 

- Единственное опциональное, необязательное ограничение.
- Предполагает отправку сервером исполняемого кода клиенту. Это то, что происходит в HTML-теге 
  `<script>`
- Когда HTML-документ загружается, браузер автоматически выбирает на сервере JavaScript и 
исполняет его локально.
 

###Модель зрелости RESTful

![Модель зрелости RESTful](https://github.com/nimestel/auto-qa-tech-interview/blob/master/screenshots
/rest_maturity_model.png "Модель зрелости RESTful")

- 0 - болото, кидаем джейсончики/xml на один и тот же адрес и получаем ОК
- 1 - делим эндпоинты по разным урл на разные ресурсы, которые юзают один и тот же метод http, 
  ответ всегда 200 ОК
- 2 - то же самое и юзаем разные методы и разные коды ответов
- 3 - в ответах на запросы присылаем объекты-линки, что из этого объекта можно вызвать еще 
  (принцип не прижился)



